# Organizational Data Core Package

This package provides the core functionality for accessing and querying organizational data in a performant, indexed manner.

## Overview

The `orgdatacore` package is designed to be a reusable component that can be consumed by multiple services including:
- Slack bots (ci-chat-bot)
- REST APIs
- CLI tools
- Other organizational data consumers

## Features

- Pre-computed indexes for O(1) lookups
- Thread-safe with read-write mutex protection
- Hot reload via `Watch()` without restart
- GCS data source with optional SDK
- Custom data source support via `DataSource` interface

## Usage

### Google Cloud Storage Setup

GCS is the supported production data source for this package.


For GCS support, build with the `gcs` tag:

```bash
go get cloud.google.com/go/storage
go build -tags gcs
```

```go
package main

import (
    "context"
    "log"
    "time"
    orgdatacore "github.com/openshift-eng/cyborg-data/go"
)

func main() {
    service := orgdatacore.NewService()

    // Configure GCS
    config := orgdatacore.GCSConfig{
        Bucket:        "orgdata-sensitive",
        ObjectPath:    "orgdata/comprehensive_index_dump.json",
        ProjectID:     "your-project-id",
        CheckInterval: 5 * time.Minute,
        // Optional: provide service account credentials directly
        // CredentialsJSON: `{"type":"service_account",...}`,
    }

    // Load from GCS using the SDK implementation
    gcsSource, err := orgdatacore.NewGCSDataSourceWithSDK(context.Background(), config)
    if err != nil {
        log.Fatal(err)
    }

    err = service.LoadFromDataSource(context.Background(), gcsSource)
    if err != nil {
        log.Fatal(err)
    }

    // Start watching for GCS changes
    service.StartDataSourceWatcher(context.Background(), gcsSource)
}
```

## Data Structure

The package expects data in the `comprehensive_index_dump.json` format generated by the Python `orglib` indexing system from the cyborg project.

## Service Architecture

### Query Performance
All queries use **pre-computed indexes** for O(1) performance:

- **Employee lookups**: Direct map access via UID, Slack ID, or GitHub ID
- **Team membership**: Pre-computed membership index eliminates tree traversal
- **Organization hierarchy**: Flattened relationship index for instant ancestry queries
- **Slack mappings**: Dedicated index for Slack ID → UID resolution
- **GitHub mappings**: Dedicated index for GitHub ID → UID resolution

### Thread Safety
The service uses **read-write mutex protection**:
- **Read operations** (queries): Multiple concurrent readers supported
- **Write operations** (data loading): Exclusive access during updates
- **Hot reload**: Atomic data replacement without query interruption

### Data Structure Optimization
```go
// Optimized for fast lookups
type Data struct {
    Metadata Metadata // Summary statistics
    Lookups  Lookups  // Direct object access: O(1)
    Indexes  Indexes  // Pre-computed relationships: O(1)
}

// Example: Employee lookup
employee := data.Lookups.Employees[uid]  // Direct map access

// Example: Team membership
memberships := data.Indexes.Membership.MembershipIndex[uid]  // Pre-computed list
```

## Service Methods

### Employee Queries
```go
// Primary employee lookup by UID
employee := service.GetEmployeeByUID("jsmith")

// Slack integration - lookup by Slack user ID
employee = service.GetEmployeeBySlackID("U123ABC456")

// GitHub integration - lookup by GitHub username
employee = service.GetEmployeeByGitHubID("jsmith-dev")

// Email lookup (case-insensitive)
employee = service.GetEmployeeByEmail("jsmith@example.com")

// Get employee's manager
manager := service.GetManagerForEmployee("jsmith")
// Returns the manager's Employee record, or nil if no manager

// Returns *Employee with fields:
//   - UID, FullName, Email, JobTitle
//   - SlackUID, GitHubID
//   - RhatGeo, CostCenter
//   - ManagerUID, IsPeopleManager
```

### Team Operations
```go
// Get team details
team := service.GetTeamByName("Platform SRE")

// Get all teams for an employee
teams := service.GetTeamsForUID("jsmith")
teams = service.GetTeamsForSlackID("U123ABC456")

// Check team membership
isMember := service.IsEmployeeInTeam("jsmith", "Platform SRE")
isSlackMember := service.IsSlackUserInTeam("U123ABC456", "Platform SRE")

// Get all team members
members := service.GetTeamMembers("Platform SRE")

// Get all team names
allTeams := service.GetAllTeamNames()
```

### Organization Queries
```go
// Get organization details
org := service.GetOrgByName("Engineering")

// Check organization membership (includes inherited via teams)
isMember := service.IsEmployeeInOrg("jsmith", "Engineering")
isSlackMember := service.IsSlackUserInOrg("U123ABC456", "Engineering")

// Get complete organizational context
orgs := service.GetUserOrganizations("U123ABC456")
// Returns: teams, orgs, pillars, team_groups user belongs to

// Get all organization names
allOrgs := service.GetAllOrgNames()
```

### Pillar Queries
```go
// Get pillar details
pillar := service.GetPillarByName("Platform Engineering")

// Get all pillar names
allPillars := service.GetAllPillarNames()
```

### Team Group Queries
```go
// Get team group details
teamGroup := service.GetTeamGroupByName("Backend Teams")

// Get all team group names
allTeamGroups := service.GetAllTeamGroupNames()
```

### Enumeration Methods
```go
// Get all UIDs, team names, org names, pillar names, team group names
employeeUIDs := service.GetAllEmployeeUIDs()
teamNames := service.GetAllTeamNames()
orgNames := service.GetAllOrgNames()
pillarNames := service.GetAllPillarNames()
teamGroupNames := service.GetAllTeamGroupNames()
```

### Iterator-Based Enumeration (Go 1.23+)
```go
// Iterate over all employee UIDs
for uid := range service.AllEmployeeUIDs() {
    fmt.Println(uid)
}

// Iterate over all employees
for emp := range service.AllEmployees() {
    if emp.IsPeopleManager {
        fmt.Printf("Manager: %s\n", emp.FullName)
    }
}

// Iterate over teams with key-value pairs
for name, team := range service.AllTeams() {
    fmt.Printf("Team: %s (type: %s)\n", name, team.Type)
}

// Similarly for orgs, pillars, and team groups:
// - AllOrgNames() / AllOrgs()
// - AllPillarNames() / AllPillars()
// - AllTeamGroupNames() / AllTeamGroups()
```

**Iterator Safety**: Iterators use a snapshot approach - data is collected while briefly
holding a read lock, then iteration proceeds without holding any lock. This is safe
for concurrent use and allows slow consumer operations without blocking other readers.

### Performance Characteristics
| Operation | Complexity | Index Used |
|-----------|------------|------------|
| `GetEmployeeByUID` | O(1) | `lookups.employees` |
| `GetEmployeeBySlackID` | O(1) | `indexes.slack_id_mappings` |
| `GetEmployeeByGitHubID` | O(1) | `indexes.github_id_mappings` |
| `GetEmployeeByEmail` | O(n) | Linear scan (n = employees) |
| `GetManagerForEmployee` | O(1) | `lookups.employees` (2 lookups) |
| `GetTeamByName` | O(1) | `lookups.teams` |
| `GetOrgByName` | O(1) | `lookups.orgs` |
| `GetPillarByName` | O(1) | `lookups.pillars` |
| `GetTeamGroupByName` | O(1) | `lookups.team_groups` |
| `GetTeamsForUID` | O(1) | `indexes.membership.membership_index` |
| `IsEmployeeInTeam` | O(n) | Pre-computed membership (n = teams) |
| `GetUserOrganizations` | O(1) | Flattened hierarchy index |
| `GetAllEmployeeUIDs` | O(n) | Map key iteration |
| `AllEmployeeUIDs()` | O(n) | Snapshot + iteration |
| `AllEmployees()` | O(n) | Snapshot + iteration |

**No expensive tree traversals** - all organizational relationships are pre-computed during indexing.

## Employee Structure

The `Employee` type includes comprehensive fields:

```go
type Employee struct {
    // Core identity
    UID      string `json:"uid"`
    FullName string `json:"full_name"`
    Email    string `json:"email"`
    JobTitle string `json:"job_title"`

    // External integrations
    SlackUID string `json:"slack_uid,omitempty"`
    GitHubID string `json:"github_id,omitempty"`

    // Organizational data
    RhatGeo         string `json:"rhat_geo,omitempty"`
    CostCenter      int    `json:"cost_center,omitempty"`
    ManagerUID      string `json:"manager_uid,omitempty"`
    IsPeopleManager bool   `json:"is_people_manager,omitempty"`
}
```

## Organizational Entities

All organizational entities (Team, Org, Pillar, TeamGroup) share a common structure:

```go
type Team struct {
    UID         string
    Name        string
    TabName     string
    Description string
    Type        string
    Group       Group  // Rich metadata
}
```

### Group Metadata

The `Group` structure contains rich metadata for teams and organizations:

```go
type Group struct {
    Type                  GroupType
    ResolvedPeopleUIDList []string

    // Slack integration
    Slack *SlackConfig  // Channels and aliases

    // Team structure
    Roles []RoleInfo  // People assignments to roles

    // Project tracking
    Jiras []JiraInfo  // Jira project/component mappings
    Repos []RepoInfo  // GitHub repositories

    // Communication
    Emails   []EmailInfo      // Team email addresses
    Keywords []string         // Search keywords

    // Documentation
    Resources []ResourceInfo  // Links to wikis, docs, etc.

    // Ownership
    ComponentRoles []ComponentRoleInfo  // Component ownership
}
```

**SlackConfig** includes:
- `Channels` - Channel configurations with IDs, descriptions, and types
- `Aliases` - Slack handle aliases with descriptions

**RoleInfo** includes:
- `People` - List of UIDs assigned to the role
- `Types` - Role types (manager, qe, team_lead, etc.)

**JiraInfo** includes:
- `Project`, `Component`, `Description`, `View`, `Types`

**RepoInfo** includes:
- `Repo`, `Description`, `Tags`, `Path`, `Roles`, `Branch`, `Types`

## Data Sources

The package supports pluggable data sources through the `DataSource` interface:

### GCS Data Source

Requires `-tags gcs` build flag and GCS SDK.

- Hot reload via generation-based polling
- Uses ADC or service account JSON credentials

### Custom Data Sources

Implement the `DataSource` interface for custom sources:

```go
type DataSource interface {
    Load(ctx context.Context) (io.ReadCloser, error)
    Watch(ctx context.Context, callback func() error) error
    String() string
    io.Closer
}
```

## Logging

The package uses structured logging via the `logr` interface, making it compatible with OpenShift and Kubernetes logging standards.

**Default**: Uses `stdr` (standard library logger wrapper)

**OpenShift Integration**:
```go
import "k8s.io/klog/v2/klogr"
import orgdatacore "github.com/openshift-eng/cyborg-data/go"

func init() {
    orgdatacore.SetLogger(klogr.New())
}
```

Log events include data source changes, reload operations, and error conditions with structured key-value context.

## Examples

See the `example/` directory for working examples:

- **`example/comprehensive`** - Comprehensive example showing all major features
- **`example/with-gcs`** - GCS-specific example with hot reload

Build examples with:
```bash
cd example/comprehensive && go build -o ./comprehensive .
cd example/with-gcs && go build -tags gcs -o ./with-gcs .
```

## Dependencies

- Go 1.23.0+
- Build with `-tags gcs` for production use
- GCS SDK required for production: `cloud.google.com/go/storage`
- `github.com/go-logr/logr` for structured logging
